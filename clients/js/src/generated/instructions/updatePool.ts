/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  getBooleanDecoder,
  getBooleanEncoder,
  getI64Decoder,
  getI64Encoder,
  getOptionDecoder,
  getOptionEncoder,
  getStructDecoder,
  getStructEncoder,
  getU64Decoder,
  getU64Encoder,
  getU8Decoder,
  getU8Encoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type Option,
  type OptionOrNullable,
  type ReadonlyAccount,
  type ReadonlySignerAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
} from '@solana/kit';
import { STAKE_POOL_PROGRAM_ADDRESS } from '../programs';
import { getAccountMetaFactory, type ResolvedAccount } from '../shared';

export const UPDATE_POOL_DISCRIMINATOR = 4;

export function getUpdatePoolDiscriminatorBytes() {
  return getU8Encoder().encode(UPDATE_POOL_DISCRIMINATOR);
}

export type UpdatePoolInstruction<
  TProgram extends string = typeof STAKE_POOL_PROGRAM_ADDRESS,
  TAccountPool extends string | AccountMeta<string> = string,
  TAccountAdmin extends string | AccountMeta<string> = string,
  TAccountProgramAuthority extends string | AccountMeta<string> = string,
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountPool extends string
        ? WritableAccount<TAccountPool>
        : TAccountPool,
      TAccountAdmin extends string
        ? ReadonlySignerAccount<TAccountAdmin> &
            AccountSignerMeta<TAccountAdmin>
        : TAccountAdmin,
      TAccountProgramAuthority extends string
        ? ReadonlyAccount<TAccountProgramAuthority>
        : TAccountProgramAuthority,
      ...TRemainingAccounts,
    ]
  >;

export type UpdatePoolInstructionData = {
  discriminator: number;
  rewardRate: Option<bigint>;
  minStakeAmount: Option<bigint>;
  lockupPeriod: Option<bigint>;
  isPaused: Option<boolean>;
  enforceLockup: Option<boolean>;
  poolEndDate: Option<Option<bigint>>;
};

export type UpdatePoolInstructionDataArgs = {
  rewardRate: OptionOrNullable<number | bigint>;
  minStakeAmount: OptionOrNullable<number | bigint>;
  lockupPeriod: OptionOrNullable<number | bigint>;
  isPaused: OptionOrNullable<boolean>;
  enforceLockup: OptionOrNullable<boolean>;
  poolEndDate: OptionOrNullable<OptionOrNullable<number | bigint>>;
};

export function getUpdatePoolInstructionDataEncoder(): Encoder<UpdatePoolInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', getU8Encoder()],
      ['rewardRate', getOptionEncoder(getU64Encoder())],
      ['minStakeAmount', getOptionEncoder(getU64Encoder())],
      ['lockupPeriod', getOptionEncoder(getI64Encoder())],
      ['isPaused', getOptionEncoder(getBooleanEncoder())],
      ['enforceLockup', getOptionEncoder(getBooleanEncoder())],
      ['poolEndDate', getOptionEncoder(getOptionEncoder(getI64Encoder()))],
    ]),
    (value) => ({ ...value, discriminator: UPDATE_POOL_DISCRIMINATOR })
  );
}

export function getUpdatePoolInstructionDataDecoder(): Decoder<UpdatePoolInstructionData> {
  return getStructDecoder([
    ['discriminator', getU8Decoder()],
    ['rewardRate', getOptionDecoder(getU64Decoder())],
    ['minStakeAmount', getOptionDecoder(getU64Decoder())],
    ['lockupPeriod', getOptionDecoder(getI64Decoder())],
    ['isPaused', getOptionDecoder(getBooleanDecoder())],
    ['enforceLockup', getOptionDecoder(getBooleanDecoder())],
    ['poolEndDate', getOptionDecoder(getOptionDecoder(getI64Decoder()))],
  ]);
}

export function getUpdatePoolInstructionDataCodec(): Codec<
  UpdatePoolInstructionDataArgs,
  UpdatePoolInstructionData
> {
  return combineCodec(
    getUpdatePoolInstructionDataEncoder(),
    getUpdatePoolInstructionDataDecoder()
  );
}

export type UpdatePoolInput<
  TAccountPool extends string = string,
  TAccountAdmin extends string = string,
  TAccountProgramAuthority extends string = string,
> = {
  /** The stake pool */
  pool: Address<TAccountPool>;
  /** The global admin (authorized in ProgramAuthority) */
  admin: TransactionSigner<TAccountAdmin>;
  /** The program authority account (validates admin permission) */
  programAuthority: Address<TAccountProgramAuthority>;
  rewardRate: UpdatePoolInstructionDataArgs['rewardRate'];
  minStakeAmount: UpdatePoolInstructionDataArgs['minStakeAmount'];
  lockupPeriod: UpdatePoolInstructionDataArgs['lockupPeriod'];
  isPaused: UpdatePoolInstructionDataArgs['isPaused'];
  enforceLockup: UpdatePoolInstructionDataArgs['enforceLockup'];
  poolEndDate: UpdatePoolInstructionDataArgs['poolEndDate'];
};

export function getUpdatePoolInstruction<
  TAccountPool extends string,
  TAccountAdmin extends string,
  TAccountProgramAuthority extends string,
  TProgramAddress extends Address = typeof STAKE_POOL_PROGRAM_ADDRESS,
>(
  input: UpdatePoolInput<TAccountPool, TAccountAdmin, TAccountProgramAuthority>,
  config?: { programAddress?: TProgramAddress }
): UpdatePoolInstruction<
  TProgramAddress,
  TAccountPool,
  TAccountAdmin,
  TAccountProgramAuthority
> {
  // Program address.
  const programAddress = config?.programAddress ?? STAKE_POOL_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    pool: { value: input.pool ?? null, isWritable: true },
    admin: { value: input.admin ?? null, isWritable: false },
    programAuthority: {
      value: input.programAuthority ?? null,
      isWritable: false,
    },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.pool),
      getAccountMeta(accounts.admin),
      getAccountMeta(accounts.programAuthority),
    ],
    data: getUpdatePoolInstructionDataEncoder().encode(
      args as UpdatePoolInstructionDataArgs
    ),
    programAddress,
  } as UpdatePoolInstruction<
    TProgramAddress,
    TAccountPool,
    TAccountAdmin,
    TAccountProgramAuthority
  >);
}

export type ParsedUpdatePoolInstruction<
  TProgram extends string = typeof STAKE_POOL_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    /** The stake pool */
    pool: TAccountMetas[0];
    /** The global admin (authorized in ProgramAuthority) */
    admin: TAccountMetas[1];
    /** The program authority account (validates admin permission) */
    programAuthority: TAccountMetas[2];
  };
  data: UpdatePoolInstructionData;
};

export function parseUpdatePoolInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>
): ParsedUpdatePoolInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 3) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      pool: getNextAccount(),
      admin: getNextAccount(),
      programAuthority: getNextAccount(),
    },
    data: getUpdatePoolInstructionDataDecoder().decode(instruction.data),
  };
}
