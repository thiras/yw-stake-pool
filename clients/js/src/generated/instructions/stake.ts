/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  getI64Decoder,
  getI64Encoder,
  getOptionDecoder,
  getOptionEncoder,
  getStructDecoder,
  getStructEncoder,
  getU64Decoder,
  getU64Encoder,
  getU8Decoder,
  getU8Encoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type Option,
  type OptionOrNullable,
  type ReadonlyAccount,
  type ReadonlySignerAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
  type WritableSignerAccount,
} from '@solana/kit';
import { STAKE_POOL_PROGRAM_ADDRESS } from '../programs';
import { getAccountMetaFactory, type ResolvedAccount } from '../shared';

export const STAKE_DISCRIMINATOR = 2;

export function getStakeDiscriminatorBytes() {
  return getU8Encoder().encode(STAKE_DISCRIMINATOR);
}

export type StakeInstruction<
  TProgram extends string = typeof STAKE_POOL_PROGRAM_ADDRESS,
  TAccountPool extends string | AccountMeta<string> = string,
  TAccountStakeAccount extends string | AccountMeta<string> = string,
  TAccountOwner extends string | AccountMeta<string> = string,
  TAccountUserTokenAccount extends string | AccountMeta<string> = string,
  TAccountStakeVault extends string | AccountMeta<string> = string,
  TAccountRewardVault extends string | AccountMeta<string> = string,
  TAccountStakeMint extends string | AccountMeta<string> = string,
  TAccountTokenProgram extends
    | string
    | AccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',
  TAccountPayer extends string | AccountMeta<string> = string,
  TAccountSystemProgram extends
    | string
    | AccountMeta<string> = '11111111111111111111111111111111',
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountPool extends string
        ? WritableAccount<TAccountPool>
        : TAccountPool,
      TAccountStakeAccount extends string
        ? WritableAccount<TAccountStakeAccount>
        : TAccountStakeAccount,
      TAccountOwner extends string
        ? ReadonlySignerAccount<TAccountOwner> &
            AccountSignerMeta<TAccountOwner>
        : TAccountOwner,
      TAccountUserTokenAccount extends string
        ? WritableAccount<TAccountUserTokenAccount>
        : TAccountUserTokenAccount,
      TAccountStakeVault extends string
        ? WritableAccount<TAccountStakeVault>
        : TAccountStakeVault,
      TAccountRewardVault extends string
        ? ReadonlyAccount<TAccountRewardVault>
        : TAccountRewardVault,
      TAccountStakeMint extends string
        ? ReadonlyAccount<TAccountStakeMint>
        : TAccountStakeMint,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      TAccountPayer extends string
        ? WritableSignerAccount<TAccountPayer> &
            AccountSignerMeta<TAccountPayer>
        : TAccountPayer,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      ...TRemainingAccounts,
    ]
  >;

export type StakeInstructionData = {
  discriminator: number;
  amount: bigint;
  index: bigint;
  expectedRewardRate: Option<bigint>;
  expectedLockupPeriod: Option<bigint>;
};

export type StakeInstructionDataArgs = {
  amount: number | bigint;
  index: number | bigint;
  expectedRewardRate: OptionOrNullable<number | bigint>;
  expectedLockupPeriod: OptionOrNullable<number | bigint>;
};

export function getStakeInstructionDataEncoder(): Encoder<StakeInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', getU8Encoder()],
      ['amount', getU64Encoder()],
      ['index', getU64Encoder()],
      ['expectedRewardRate', getOptionEncoder(getU64Encoder())],
      ['expectedLockupPeriod', getOptionEncoder(getI64Encoder())],
    ]),
    (value) => ({ ...value, discriminator: STAKE_DISCRIMINATOR })
  );
}

export function getStakeInstructionDataDecoder(): Decoder<StakeInstructionData> {
  return getStructDecoder([
    ['discriminator', getU8Decoder()],
    ['amount', getU64Decoder()],
    ['index', getU64Decoder()],
    ['expectedRewardRate', getOptionDecoder(getU64Decoder())],
    ['expectedLockupPeriod', getOptionDecoder(getI64Decoder())],
  ]);
}

export function getStakeInstructionDataCodec(): Codec<
  StakeInstructionDataArgs,
  StakeInstructionData
> {
  return combineCodec(
    getStakeInstructionDataEncoder(),
    getStakeInstructionDataDecoder()
  );
}

export type StakeInput<
  TAccountPool extends string = string,
  TAccountStakeAccount extends string = string,
  TAccountOwner extends string = string,
  TAccountUserTokenAccount extends string = string,
  TAccountStakeVault extends string = string,
  TAccountRewardVault extends string = string,
  TAccountStakeMint extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountPayer extends string = string,
  TAccountSystemProgram extends string = string,
> = {
  /** The stake pool */
  pool: Address<TAccountPool>;
  /** The user's new stake account */
  stakeAccount: Address<TAccountStakeAccount>;
  /** The stake account owner */
  owner: TransactionSigner<TAccountOwner>;
  /** User's token account */
  userTokenAccount: Address<TAccountUserTokenAccount>;
  /** Pool's stake vault */
  stakeVault: Address<TAccountStakeVault>;
  /** Pool's reward vault (for checking available rewards) */
  rewardVault: Address<TAccountRewardVault>;
  /** The token mint being staked */
  stakeMint: Address<TAccountStakeMint>;
  /** The token program (Token or Token-2022) */
  tokenProgram?: Address<TAccountTokenProgram>;
  /** The account paying for rent */
  payer: TransactionSigner<TAccountPayer>;
  /** The system program */
  systemProgram?: Address<TAccountSystemProgram>;
  amount: StakeInstructionDataArgs['amount'];
  index: StakeInstructionDataArgs['index'];
  expectedRewardRate: StakeInstructionDataArgs['expectedRewardRate'];
  expectedLockupPeriod: StakeInstructionDataArgs['expectedLockupPeriod'];
};

export function getStakeInstruction<
  TAccountPool extends string,
  TAccountStakeAccount extends string,
  TAccountOwner extends string,
  TAccountUserTokenAccount extends string,
  TAccountStakeVault extends string,
  TAccountRewardVault extends string,
  TAccountStakeMint extends string,
  TAccountTokenProgram extends string,
  TAccountPayer extends string,
  TAccountSystemProgram extends string,
  TProgramAddress extends Address = typeof STAKE_POOL_PROGRAM_ADDRESS,
>(
  input: StakeInput<
    TAccountPool,
    TAccountStakeAccount,
    TAccountOwner,
    TAccountUserTokenAccount,
    TAccountStakeVault,
    TAccountRewardVault,
    TAccountStakeMint,
    TAccountTokenProgram,
    TAccountPayer,
    TAccountSystemProgram
  >,
  config?: { programAddress?: TProgramAddress }
): StakeInstruction<
  TProgramAddress,
  TAccountPool,
  TAccountStakeAccount,
  TAccountOwner,
  TAccountUserTokenAccount,
  TAccountStakeVault,
  TAccountRewardVault,
  TAccountStakeMint,
  TAccountTokenProgram,
  TAccountPayer,
  TAccountSystemProgram
> {
  // Program address.
  const programAddress = config?.programAddress ?? STAKE_POOL_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    pool: { value: input.pool ?? null, isWritable: true },
    stakeAccount: { value: input.stakeAccount ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: false },
    userTokenAccount: {
      value: input.userTokenAccount ?? null,
      isWritable: true,
    },
    stakeVault: { value: input.stakeVault ?? null, isWritable: true },
    rewardVault: { value: input.rewardVault ?? null, isWritable: false },
    stakeMint: { value: input.stakeMint ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    payer: { value: input.payer ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.pool),
      getAccountMeta(accounts.stakeAccount),
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.userTokenAccount),
      getAccountMeta(accounts.stakeVault),
      getAccountMeta(accounts.rewardVault),
      getAccountMeta(accounts.stakeMint),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.systemProgram),
    ],
    data: getStakeInstructionDataEncoder().encode(
      args as StakeInstructionDataArgs
    ),
    programAddress,
  } as StakeInstruction<
    TProgramAddress,
    TAccountPool,
    TAccountStakeAccount,
    TAccountOwner,
    TAccountUserTokenAccount,
    TAccountStakeVault,
    TAccountRewardVault,
    TAccountStakeMint,
    TAccountTokenProgram,
    TAccountPayer,
    TAccountSystemProgram
  >);
}

export type ParsedStakeInstruction<
  TProgram extends string = typeof STAKE_POOL_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    /** The stake pool */
    pool: TAccountMetas[0];
    /** The user's new stake account */
    stakeAccount: TAccountMetas[1];
    /** The stake account owner */
    owner: TAccountMetas[2];
    /** User's token account */
    userTokenAccount: TAccountMetas[3];
    /** Pool's stake vault */
    stakeVault: TAccountMetas[4];
    /** Pool's reward vault (for checking available rewards) */
    rewardVault: TAccountMetas[5];
    /** The token mint being staked */
    stakeMint: TAccountMetas[6];
    /** The token program (Token or Token-2022) */
    tokenProgram: TAccountMetas[7];
    /** The account paying for rent */
    payer: TAccountMetas[8];
    /** The system program */
    systemProgram: TAccountMetas[9];
  };
  data: StakeInstructionData;
};

export function parseStakeInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>
): ParsedStakeInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 10) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      pool: getNextAccount(),
      stakeAccount: getNextAccount(),
      owner: getNextAccount(),
      userTokenAccount: getNextAccount(),
      stakeVault: getNextAccount(),
      rewardVault: getNextAccount(),
      stakeMint: getNextAccount(),
      tokenProgram: getNextAccount(),
      payer: getNextAccount(),
      systemProgram: getNextAccount(),
    },
    data: getStakeInstructionDataDecoder().decode(instruction.data),
  };
}
